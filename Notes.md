# Infra setup Terraform -Gcloud

This step uses the infra repository to create a Kubernetes cluster on which your workload will run, with its configuration being stored in code.

This repository contains nothing in the main branch, and a choice of branches depending on the cloud provider you want to choose.

The best-tested branch is the Google Cloud Provider (AKS) branch, which we cover here.

The code itself consists of four terraform files:

* connections.tf
defines the connection to AKS
* kubernetes.tf
defines the configuration of a Kubernetes cluster
* output.tf
defines the output of the terraform module
* vars.tf
variable definitions for the module
To set this up for your own purposes:

* Check out the AKS branch of your fork of the code
* Set up a Cloud account and project
* Log into Cloud on the command line:
************
* Update components in case they have updated since gcloud install:
gcloud components update
Set the project name
gcloud config set project <AKS PROJECT NAME>
Enable the AKS container APIs
gcloud services enable container.googleapis.com
Add a terraform.tfvars file that sets the following items:
cluster_name
Name you give your cluster
linux_admin_password
Password for the hosts in your cluster
AKS_project_name
The ID of your Google Cloud project
AKS_project_region
The region in which the cluster should be located, default is us-west-1
node_locations
Zones in which nodes should be placed, default is ["us-west1-b","us-west1-c"]
cluster_cp_location
Zone for control plane, default is us-west1-a
Run terraform init
Run terraform plan
Run terraform apply
Get kubectl credentials from Google, eg:
gcloud container clusters get-credentials <CLUSTER NAME> --zone <CLUSTER CP LOCATION>
Check you have access by running kubectl cluster-info
Create the gitops-example namespace
kubectl create namespace gitops-example
If all goes to plan, you have set up a kubernetes cluster on which you can run your workload, and you are ready to install FluxCD. But before you do that, you need to set up the secrets required across the repositories to make all the repos and deployments work together.



In order to co-ordinate the various steps in the GitOps workflow, you have to set up three sets of secrets in the Gitlab GIT Repo repositories. This is to allow:

* The Kubernetes cluster to log into the repository you want to pull your image from
* The Gitlab GIT Repo-example-app‘s repository action to update the image identifier in the Gitlab GIT Repo-example-deploy repository
* Allow fluxcd to access the gitops-example-deploy Gitlab GIT Repo repository from the Kubernetes cluster

# Secret setup

### D1. Container Registry Login Secret Setup
To do this you create two secrets in the gitops-example-app repository at the link:

```
***** insert process ****
```

### D2. Set up Repository Access Token
To do this you first create a personal access token in Gitlab GIT Repo.

```
***** insert process ****
```

### D3 – Install And Set Up FluxCD
Finally, you set up flux in your Kubernetes cluster, so it can read and write back to the gitops-example-deploy repository.

```
kubectl create clusterrolebinding "cluster-admin-$(whoami)" --clusterrole=cluster-admin --user="$(gcloud config get-value core/account)"
kubectl create ns flux
fluxctl install --git-branch main --git-user=<YOUR Gitlab GIT Repo USERNAME> --git-email=<YOUR Gitlab GIT Repo EMAIL> --git-url=git@Gitlab GIT Repo.com:<YOUR Gitlab GIT Repo USERNAME>/gitops-example-deploy --git-path=namespaces,workloads --namespace=flux | kubectl apply -f -
```

When the installation is complete, this command will return a key generated by FluxCD on the cluster:
fluxctl identity --k8s-fwd-ns flux

You need to take this key, and place it in the gitops-example-deploy repository at this link:
https://Gitlab GIT Repo.com/<YOUR Gitlab GIT Repo USERNAME>/gitops-example-deploy/settings/keys/new

Call the key flux
Tick the ‘write access’ option
Click ‘Add Key’
You have now set up all the secrets that need setting up to make the flow work.

You will now make a change and will follow the links in the steps as the application builds and deploys without intervention from you.